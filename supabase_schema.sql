-- Supabase PostgreSQL Schema

-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Courses Table
CREATE TABLE IF NOT EXISTS courses (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  university TEXT NOT NULL,
  course_code TEXT NOT NULL,
  title TEXT NOT NULL,
  units TEXT,
  description TEXT,
  url TEXT,
  details JSONB,
  department TEXT,
  corequisites TEXT,
  level TEXT,
  difficulty DOUBLE PRECISION,
  popularity INTEGER DEFAULT 0,
  workload TEXT,
  is_hidden BOOLEAN DEFAULT FALSE,
  is_internal BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(university, course_code)
);

CREATE INDEX IF NOT EXISTS idx_courses_university ON courses(university);
CREATE INDEX IF NOT EXISTS idx_courses_course_code ON courses(course_code);

-- Fields Table
CREATE TABLE IF NOT EXISTS fields (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL UNIQUE
);

-- Course-Fields Relationship
CREATE TABLE IF NOT EXISTS course_fields (
  course_id BIGINT NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
  field_id BIGINT NOT NULL REFERENCES fields(id) ON DELETE CASCADE,
  PRIMARY KEY (course_id, field_id)
);

CREATE INDEX IF NOT EXISTS idx_course_fields_field ON course_fields(field_id);

-- User Courses Table (Linking to Supabase Auth)
CREATE TABLE IF NOT EXISTS user_courses (
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  course_id BIGINT NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
  progress INTEGER DEFAULT 0 CHECK (progress >= 0 AND progress <= 100),
  status TEXT DEFAULT 'pending', -- pending, in_progress, completed, dropped
  priority INTEGER DEFAULT 0,
  gpa NUMERIC(3,2) CHECK (gpa >= 0 AND gpa <= 5.0),
  score NUMERIC(5,2) CHECK (score >= 0 AND score <= 100),
  notes TEXT,
  updated_at TIMESTAMPTZ DEFAULT now(),
  PRIMARY KEY (user_id, course_id)
);

CREATE INDEX IF NOT EXISTS idx_user_courses_user ON user_courses(user_id);
CREATE INDEX IF NOT EXISTS idx_user_courses_status ON user_courses(status);

-- Semesters Table
CREATE TABLE IF NOT EXISTS semesters (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  year INTEGER NOT NULL,
  term TEXT NOT NULL,
  UNIQUE(year, term)
);

-- Course-Semesters Relationship
CREATE TABLE IF NOT EXISTS course_semesters (
  course_id BIGINT NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
  semester_id BIGINT NOT NULL REFERENCES semesters(id) ON DELETE CASCADE,
  PRIMARY KEY (course_id, semester_id)
);

CREATE INDEX IF NOT EXISTS idx_course_semesters_semester ON course_semesters(semester_id);

-- Row Level Security (RLS)
ALTER TABLE courses ENABLE ROW LEVEL SECURITY;
ALTER TABLE fields ENABLE ROW LEVEL SECURITY;
ALTER TABLE course_fields ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_courses ENABLE ROW LEVEL SECURITY;
ALTER TABLE semesters ENABLE ROW LEVEL SECURITY;
ALTER TABLE course_semesters ENABLE ROW LEVEL SECURITY;

-- Policies
-- Public Read Access
CREATE POLICY "Allow public read access on courses" ON courses FOR SELECT USING (NOT is_hidden);
CREATE POLICY "Allow public read access on fields" ON fields FOR SELECT USING (true);
CREATE POLICY "Allow public read access on course_fields" ON course_fields FOR SELECT USING (true);
CREATE POLICY "Allow public read access on semesters" ON semesters FOR SELECT USING (true);
CREATE POLICY "Allow public read access on course_semesters" ON course_semesters FOR SELECT USING (true);

-- Authenticated User Access for user_courses
CREATE POLICY "Users can view their own enrollments" ON user_courses FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own enrollments" ON user_courses FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own enrollments" ON user_courses FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own enrollments" ON user_courses FOR DELETE USING (auth.uid() = user_id);

-- RPC Functions
CREATE OR REPLACE FUNCTION increment_popularity(row_id BIGINT)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE courses
  SET popularity = popularity + 1
  WHERE id = row_id;
END;
$$;

-- Study Plans Table
-- Stores user's study rules (e.g., Mon/Wed/Fri from 9-11am)
CREATE TABLE IF NOT EXISTS study_plans (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  course_id BIGINT NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
  start_date DATE NOT NULL,
  end_date DATE NOT NULL,
  days_of_week INTEGER[] NOT NULL, -- 0=Sun, 1=Mon, ..., 6=Sat
  start_time TIME NOT NULL DEFAULT '09:00:00',
  end_time TIME NOT NULL DEFAULT '11:00:00',
  location TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_study_plans_user ON study_plans(user_id);

-- Study Logs Table
-- Stores specific instances (exceptions, completions) for generated events
CREATE TABLE IF NOT EXISTS study_logs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  plan_id BIGINT NOT NULL REFERENCES study_plans(id) ON DELETE CASCADE,
  log_date DATE NOT NULL,
  is_completed BOOLEAN DEFAULT FALSE,
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(user_id, plan_id, log_date)
);

CREATE INDEX IF NOT EXISTS idx_study_logs_user_date ON study_logs(user_id, log_date);

-- Enable RLS
ALTER TABLE study_plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE study_logs ENABLE ROW LEVEL SECURITY;

-- Policies for study_plans
CREATE POLICY "Users can view their own plans" ON study_plans FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own plans" ON study_plans FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own plans" ON study_plans FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own plans" ON study_plans FOR DELETE USING (auth.uid() = user_id);

-- Policies for study_logs
CREATE POLICY "Users can view their own logs" ON study_logs FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own logs" ON study_logs FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own logs" ON study_logs FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own logs" ON study_logs FOR DELETE USING (auth.uid() = user_id);
